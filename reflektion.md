## Reflektioner

# Tabellreflektion kap. 2 Clean Code

| Namn och förklaring                           | Reflektion och regler från Clean Code                                                                                                           |
|-----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| 1. **MeanValueCalculations**<br> Klass där bland annat publika metoderna **calculateGeometricMeanValue (numbers)** och **calculateHarmonicMeanValue (numbers)** ingår.                                            | **Don't add Gratutious Context**<br> Klassnamnet i sig ger information om att de ingående metoderna kommer göra uträkningar kopplade till medelvärden. Nu skapar jag onödigt långa metodnamn med ändelsen "MeanValue" som inte tillför information och som dessutom riskerar att göra det svårare för mig att leta efter specifik logik i sökfunktionen. "calculateGeometric" och "calculateHarmonic" vore i stort sett lika beskrivande namn, eftersom klassnamnet som sagt vittnar om klassens syfte. Detta förekommer i samtliga klasser inom calculations och jag väljer ut dessa specifika exempel för att kokretisera.                                                                                                                                                |
|                                               |                                                                                                                                                    |
| 2. **calculateStandardDeviationValue (numbers)**<br> Publik metod i klassen **VarianceValueCalculations**                                            | **Use Intention-Revealing Names**<br> Namnet gör det tydligt vad metoden utför.<br> **Don't add Gratutious Context** <br> Till skillnad från exemepl 1 kan metoden argumenteras för behöva ändelsen "StandardDeviationValue" då det inte kan förväntas vara självklart att det är en typ av varians-värde. Om namnet vore "calculateStandard" skulle en potentiell missupffattning vara att man antar att det "officiella" namnet på värdet man räknar ut är "Standard Variance Value" vilket är fel. Dock kan man ifrågasätta använndingen av "Value" som ändelse istället för att använda namnet "calculateStandardDeviation". Att ett värde kommer räknas ut är relativt självbeskrivande och överanvändning av ändelsen "value" förekommer generellt för mycket i modulen.                                                                                                                                                   |
|                                               |                                                                                                                                                    |
| 3. **calculateRangeValue (numbers)** & **calculateInterquartileRangeValue (numbers)**<br> publika metoder i klassen **RangeValueCalculations**                                            | **Use Problem Domain Names**<br> Användandet av "calculate" här och generellt i modulen indikerar tydligt att det rör sig om statistiska koncept. "Calculate" är också ett välkänt begrepp som gör det enkelt för en användare att snabbt förstå konceptet. Det går att argumentera för att "calculate" lika väl kan ses som ett begrep inom computer science och därmed kopplas starkare till **Use Solution Domain Names** eftersom det är en välkänd matematikterm som förmodligen ofta ses inom programmering. Sett till sammanhanget anser jag dock att begreppet skapar en starkare konnotation till just statistiska koncept och problem-domänen.<br>**Pick One Word Per Concept**<br> Användandet av "calculate" i de publika metodnamnen används konsekvent i modulen vilket skapar en röd tråd som är enkel att följa. Specifikt för dessa två specifika metoder hade det varit förvirrande om jag döpte den ena till "calculateRangeValue" och den andra till "computeInterquartileRangeValue"                                                                                                                                                    |
|                                               |                                                                                                                                                    |
| 4. **VarianceValueCalculations**<br>Klassnamn                                            | **Avoid Mental Mapping** <br> Detta och övriga klassnamn klargör tydligt vad klassen innehåller. Även här används problem-domänen för att uppnå tydlighet. Ett exempel på ett enligt mig sämre namn vore "VarValueCals" där jag förkortat klassnamnet på två ställen. Det kan tyckas självklart att inte använda förkortningar som tvingar användare till "mental mapping" men jag har både själv tidigare gjort och sett kod skriven av andra utfromad på liknande vis.<br> **Class Names**<br> Detta och övriga klassnamn är substantiv som beskriver "vad klassen innehåller och inte vad den gör".                                                                                                                                                    |
|                                               |                                                                                                                                                    |
| 5. **calculateModeValue (numbers)**<br> Metodnamn i klassen **ModeValueCalculations**                                           |**Method Names**<br> Detta och metodnamnen generellt i modulen är verb som beskriver "vad logiken utför" i enighet med Clean Codes rekomendationer. Jag har inte heller varit "skämtsam" och brutit mot **Don't Be Cute** här eller i någon av de andra publika metoderna.<br> **Use Pronounceable Names**<br>Både gällande detta specifika metodnamn och i modulen i stort har jag använt namngivning som är lätt att uttala. Även detta kan ses som en självklarhet efter att ha läst Clean Code men det går att föreställa sig sammanhang där det skulle vara lockande att döpa metoden till exempelvis "calcMVal" eller liknande.                                                                                                                                                     |
|                                               |                                                                                                                                                    |

## Kort reflektion kring kap. 2 Clean Code.
En insikt jag kommit till nu efter att ha gått igenom koden och kapitlet väldigt detaljerat är att man kan sammanfatta det hela till relativt enkla riktlinjer. Man skulle kunna hävda att det hela handlar om att vara så beskrivande som möjligt med så lite tecken som möjligt. Eftersom jag har genomfört ett simpelt projekt på grund av bristande kompetens kring själva programmeringen / kodningen, känner jag att det har varit relativt enkelt att hålla sig till riktlinjerna. Därför har det kanske inte  varit så utvecklande som det kunde ha varit. Det hade varit intressant att gå igenom ett äldre projekt som jag genomfört innan jag läst kapitlet för att se skillnaderna. En aspekt som lyfts i kapitlet som jag delvis har invändningar emot är **Don't add Gratutious Context**. Jag förstår att det kan finnas problem kring onödigt långa namn och överflödig information då det kan vara svårare att söka i systemet och mer ansträngande och läsa och så vidare. Men i ett mindre projekt / modul så som mitt kan jag tycka att ändelsen "Value" i de publika metoderna tillför mer än de stjälper. Visst är det självbeskrivande att statistiska uträkningar kommer resultera i ett värde när man matar in data från en array för uträkningar. Det är just statistiska värden / nyckeltal hela modulen handlar om. Men jag tycker det finns ett argument för att "calculateMedianValue" gör modulen mer lättanvänd än om jag hade använt "calculateMedian". När jag skriver den långa versionen kan det aldrig uppstå tvivel kring vad metoden gör och den förhöjda ansträngningen i att läsa fem extra bokstäver är försvinnande liten. Å andra sidan håller jag helt med om principen i ett sammanhang kring ett större projekt och som riktlinje i ett professionellt sammanhang. Att skriva överflödiga ändelser eller liknande resulterar i förlängningen i mer arbete och svårare kod att underhålla. Jag kan också se en risk i att om man värdesätter "övertydlighet", som jag möjligen gjort, kopplat till att all kod / namnsättning genomsyras av merjobb och överflödiga tecken.

En till reflektion jag gör mer allmänt kring kapitlet är att flera av riktlinjerna överlappar varandra och att ett misstag således kan leda till andra där man bryter mot flera av riktlinjerna till följd av det första misstaget. **Avoid Encodings** och **Avoid Mental Mapping** är ett exempel på detta. Jag har förmodligen gjort misstaget tidigare att förkorta någon variabel eller liknande till någon förkortning som jag ansett att användare självklart känner till. Men detta leder ju till viss "mental mapping" och är en lärdom att ta med sig.

Ytterligare ett område i kapitlet som jag kan ha mindre invändningar emot är konflikten mellan **Use Solution Domain Names** och **Use Problem Domain Names**. Som jag tolkar författaren och stycket i boken så ska man vända sig till användande av problem-domäns-namn först när det inte finns några lämpliga computer science-termer att ta till. Även om denna modulen och kod i regel riktas till andra programmerare, så kan jag föreställa mig sammanhang där namn kopplade till problem-domänen känns mer beskrivande och lämpliga. Exempelvis skulle jag hävda att termen "Shuffle" kopplat till logiken kring skapandet av ett kortspel härstammar inom problem-domän-namn medan en term som "Randomize" känns starkare förknippad med computer science. Om jag skulle programmera ett kortspel hade jag hellre använt termen "Shuffle" eftersom jag tycker den beskriver sammanhanget bättre. Jag vet också att uppgifter (utformade av personer mycket mer kompetenta än jag inom området), som förekommit i utbildningen (webbprogrammerare), har använt uttrycket "shuffle" i beskrivningar / lösningsförslag. Självklart kan misstag göras av kompetenta programmerare, men jag tvivlar på att en majoritet skulle hävda att "Randomize" är mer lämpligt än "Shuffle". Om boken därmed går emot någon form av "best practice" delad av professionella yrkesutövare, kan jag tycka att det kan finnas fog för ifrågasättande.

## Tabellreflektion kap. 3 Clean Code

| Metodnamn och länk eller kod | Antal rader         | Reflektion |
|------------------------------|---------------------|------------|
|1. Metodnamn: **#extractModeValueFromFrequency (frequencyOfNumbers)** <br>länk: https://github.com/lb224nj/1dv610_L2/blob/main/src/calculations/modeValueCalculations.js#L34                            | 14                    | **Do One Thing**<br> Metoden följer inte principen om att endast göra en sak. För att följa den principen kunde jag delat upp metoden i tre separata metoder. Jag kunde brytit ut logiken kring initiering av modeValue och highestFrequency räknaren till en separat metod. Vidare kunde jag gjort samma sak gällande uppdateringen av modeValue och highestFrequency som för närvarande sker i loopen i #extractModeValueFromFrequency.<br>**Have No Side Effects**<br>Denna princip följer metoden bättre. Logiken sker efter inmatad data (frequencyOfNumbers skapad i #calculateFrequencyOfNumbers) och returnerar ett resultat /värde (modeValue) utan att metoden påverkar globala variabler eller något annat utanför metodens scope.         |
|2. Metodnamn: **#checkArraysInput (numbers)** <br>länk: https://github.com/lb224nj/1dv610_L2/blob/main/src/inputValidator.js#L12                         |  13                   | **Do One Thing**<br> Återigen går det att diskutera logiken kring om metoden bör delas upp i mindre beståndsdelar. Jag skulle argumentera för att metoden gör en sak (kontrollerar input i en array) fast genom olika typer av kontroller. Även om det skulle gå att bryta upp den i tre delar där en metod kontrollerar att det är en array, en andra kontrollerar att arrayen inte är tom och en tredje att arrayen endast innehåller nummer, så anser jag att alla tre operationer samlade i en metod skapar hög cohesion och att metoden ur ett högre perspektiv gör en enskild grundläggande sak - nämligen kontrollerar input. Å andra sidan vore inte ett utbrytande särskilt negativt påverkande för just cohesion, då den utbrutna logiken hade placerats i privata hjälpmetoder i samma klass. <br>**Error Handling Is One Thing**<br> Denna princip ser jag som relevant för metoden eftersom den är dedikerad för just felhantering genom valideringen. Alltså är det positivt att den hanterar erros och inget annat.          |
|3. Metodnamn: **#calculateFrequencyOfNumbers (numbers)** <br>länk: https://github.com/lb224nj/1dv610_L2/blob/main/src/calculations/modeValueCalculations.js#L13                          | 12                    | **Small!**<br> Metoden är liten och fokuserad på en specifik sak med låg nivå av komplexitet. Men det går att argumentera för att den skulle kunna göras ännu mindre och tydligare genom att bryta ut logik. Som den är nu ser jag inga större problem i storleken men det går att föreställa sig ett sammanhang där jag skulle vilja tillföra mer logik till den. Om jag exempelvis skulle vilja skapa logik för ett edge case där nollor inte ska räknas gällande frekvens eller liknande skulle metoden kunna växa till att inte längre räknas som kort. Om man utgår från perspektivet att kod kan komma att förändras och uppdateras ser jag en lärdom i att redan från början hålla metoder så korta som möjligt. Jag misstänker att detta synsätt i längden skulle hjälpa en som programmerare i och med att det sparar tid då man slipper bryta ut saker som ska uppdateras eller liknande. Just det här exemplet gäller dock en privat metod som inte syftar till att ändras av andra programmerare som ska använda modulen men ur ett bredare perspektiv tror jag det är en bra grundinställning att hålla metoder och funktioner så korta, som möjligt just för att förenkla underhållning och utveckling av koden.           |
|4. Metodnamn: **#splitArrayInHalf (numbers)** <br>länk: https://github.com/lb224nj/1dv610_L2/blob/main/src/calculations/rangeValueCalculations.js#L69                           | 11                    | **Reading Code from Top to Bottom: The Stepdown Rule**<br> Metoden är enkel att följa och håpller sig till en och samma abstraktionsnivå. Den gör inga anrop till metoder på lägre abstraktionsnivå eller liknande och håller sig till sitt syfta att dela upp en array i två delar utan att använda logik på olika nivåer. Den är också enkelt läsbar uppifrån och ner. Ett sätt man kan göra abstraktionsnivån mer komplex och som jag garanterat oavsikligt gjort tidigare är om jag exempelvis skulle använt något i stil med this.#valideraArrayHalvor(undreHalva, övreHalva) och tillfört extra valideringslogik som kunde utförts utanför i en separat metod.          |
|5. Metodnamn: **calculateModeValue (numbers)** <br>länk: https://github.com/lb224nj/1dv610_L2/blob/main/src/calculations/modeValueCalculations.js#L56                         | 10                    | **Blocks and Indenting**<br> Metoden utnyttjar privata hjälpmetoder som gör att den inte behöver mycket indentering och hälper läsbarheten. Användandet av privata hjälpmetoder gör också att metoden bättre följer **Do One Thing** då logik som att räkna ut frekvensen av specifika nummer i arrayen är utbruten. Dock kan man argumentera för att if satsen som kontrollerar om det finns ett eller flera mode values gör att metoden inte endast räknar ut mode value som den syftar till, utan också gör en simpel kontroll relaterat till vad som ska returneras. Jag lyckas alltså delvis men inte helt följa principen om att metoden ska göra en sak. Min syn på det här är att principen kring **Do One Thing** kan implementeras olika bokstavligt och till olika grad. Personligen hade jag möjligen ansett det vara mer omständigt att läsa kod där if satsen är utbryten för att följa principen. Jag kan uppleva att metoden nästan känns tom om ingen operation eller intern logik mer än användandet av privata hjälpmetoder faktiskt sker i den. Å andra sidan har jag redan brutit ur andra delar ur den och hade jag brutit även if satsen så hade metoden blivit mindre i enighet med **Small!**. För att vara konsekvent vore det därför bättre om jag också hade brutit ut if satsen.<br>Det finns också en aspekt kring inkapsling och det faktum att metoden är en del av det publika interfacet. Genom att bryta ut if satsen till en privat metod hade jag skyddat den bättre.            |

## Kort reflektion kring kap. 3 Clean Code.
Precis som i kaptiel två tycker jag att det finns en tydlig aspekt kring att de olika principerna ihop skapar ett helhetsperspektiv som framstår som effektivt att följa. Det är tydligt att brytande mot en princip, ofta leder till brytande av andra och en form av ond cirkel uppstår. Exempelvis är det lätt att tänka sig att en metod som bryter mot **Do One Thing** leder till att den bryter mot principen om **Small!** och **Blocks and Indenting** och risken för brytande mot **One Level of Abstraction per Function** bör öka ju större metoden / funktionen blir eftersom det blir svårt att hålla koll på logiken. Jag inser också att jag tidigare har brytit mot just dessa principer och att skapa kod som är lätt att underhålla och "bra" är svårt. Att överhuvudtaget kunna se att en metod har logik från olika abstraktionsnivåer eller skapar sidoeffekter kräver viss kunskap / kompetens och ett synsätt på programmering som jag inte tidigare haft. Precis som i kapitel 2 inser jag värdet i att anamma dessa principer och att det förmodligen gör en till en mer kompetent utvecklare över tid. Vissa saker ställer jag mig dock lite frågande till. Exempelvis principen **Error Handling Is One Thing** kopplat till att metoder / funktioner ska göra en och endast en sak. Det här är fullt rimligt i ett större system eller modul men om man utvecklar en mindre modul med simpel logik, kan jag tycka att det kan framstå som omständigt att inte ha validering eller felhantering direkt i den relevanta metoden. Så länge som det är tydligt och lättöverskådligt vad metoden gör kan jag tycka att sådana "genvägar" bör vara godkända. Å andra sidan förenklar man förmodligen för sig själv, för andra programmerare och för underhåll i allmänhet om man följer principer som denna.

Stycket som handlar om **Triads** upplever jag intressant eftersom jag känner igen egna brister i det. De funktioner och metoder som jag haft svårast att förstå, oavsett om jag skrivit dem själv eller inte, inser jag nu oftast har innehållit flera argument. Om det är möjligt bör man därför bryta ut logik för att hålla sig till max två argument i en metod eller funktion. Ett sådant potentiellt sätt som lyfts i boken och som jag bör börja använda i sådana fall är användandet av **Argument Objects**. Speciellt då det är en okomplex logik att skapa som jag redan använt och använder i andra sammanhang. Detta tydliggör återigen att kapitlet framförallt skapar tankar kring ett förhållningssätt till utveckling i stort, som handlar mer om inställning och metodik snarare än teknikspecifika resonemang. Stycket kring **Triads** och användandet av flera argment är därför en viktig lärdom som jag genunint tror kommer underlätta för framtida projekt. Framförallt för den egna förståelsen och läsbarheten men det bör också skapa mindre risk för fel och göra testning enklare precis som boken lyfter upp. Dessutom kan man även här se ett samband i att användning av triader eller flera argument ökar risken för långa metoder som gör fler än en sak.

Ett annat intressant stycke i boken som jag inte veteligen har brutit mot i denna modul men tidigare är **Command Query Separation**. Jag tror att tydligheten i metoder blir högre om man konsekvent bryter ut logik som utför en åtgärd från logik som kontrollerar information. Det är lätt att misstänka att metoder som både gör en förändring och returnerar ett värde kan skapa otydlighet. Återigen kommer värdet kring **Do One Thing** fram. Jag tror också att det blir lättare att skriva tester om man följer dessa principer eftersom det blir tydligare att man bör göra ett separat test för en specifik operation eller del av logiken. Vidare är även denna princip ett sätt där jag tror man lättare undviker eller åtminstone lättare upptäcker sidoeffekter.

## Kort reflektion kring engen kodkvalitet

När jag startade uppgiften hade jag som grundinställning att följa kapitlen i boken efter att ha läst igenom dem en gång. Till en början tog sig detta främst uttryck i att jag anammade att de publika metoderna skulle göra en specifik sak. Jag försökte också vara övertydlig i min namngivning och reflekterade inte så mycket mer över det hela än då. Nu när jag ser tillbaka på projektets gång inser jag att bokens två kapitel sammanspelar och bygger ett helhetsperspektiv som jag inte helt använt. Att jag bryter ut logik ur publika metoder och skapar privata hjälpmetoder är positivt men upplevs också nu som en "genväg" för att visa en fin fasad medan logiken i bakgrunden är prcis likadan som jag gjort i tidigare projekt. Om jag istället hade insett fördelarna med det här helhetsperspektivet som boken framställer skulle det inte finnas någon anledning till att inte göra de privata metoderna och den delen som inte är inom det publika interfaceet precis lika okomplicerad som det publika interfaceet. Dock handlar projektet om att komma till insikter under och efter utförandets gång vilket jag upplever att jag gjort och som jag tror de här reflektionerna vittnar om. Jag kan fortfarande känna att mitt projekt är för simpelt för att verkligen kunna utnyttja alla de principer / aspekter boken lyfter, framförallt i kapitel 3. Det vore dock svårt att gör projektet mer komplext eftersom jag som sagt har brister i kunskap till kodande i sig, som verkligen synliggörs när ett projekt ska göras utan hjälp från "llm". Samtidigt tror jag kombinationen av teori och kodande i uppgiften har gjort mig mindre beroende av yttre hjälpmedel.

En aspekt som jag är relativt nöjd med och som jag tror har varit relativ bra sedan tidigare är namngiviningen i stort. Jag tycker oftast mina projekt innehåller namn som är beeskrivande. Detta kan mycket väl bero på att jag tvivlar på min egen kompetens och minne och har undvikt förkortningar och liknande för att enkelt kunna gå igenom och förstå min egen kod. Jag tar dock med mig insikter om att det är bra att hålla namn så koncisa som möjligt så länge de är beskrivande i enighet med ** Don't Add Gratuitous Context**. Vissa överdrivet långa namn kan både krångla till sökfunktioner och förstöra kodens tydlighet då de blir ansträngande att läsa. 

Jag tror och hoppas att projektet har gett mig insikter som kommer bidra till mer förståelse och bättre kodkvalitet i framtiden. En sådan insikt är principen kring **Do One Thing**. När jag går tillbaka och kollar på äldre projekt där jag inte utgått från denna princip är det uppenbart att jag i regel snarare än undantag bryter den. Nu har projekten varit så begränsade och "små" att det oftas är relativt lätt att förstå kodsammanhangen ändå. Jag kommer dock nu till insikten att ett sådant beteende / arbetssätt är bättre att bryta nu än senare. För förr eller senare lär koden bli så pass komplex att det inte längre är lätt att följa om de olika funktionerna eller metoderna gör obegränsat mycket saker. Det är givetvis bättre att börja ändra arbetssättet nu än senare när koden är mer komplex. Vidare på samma tema är kod som följer **Small!** och är liten/kort i regel mycket lättare att läsa och förmodligen testa. Dessa två principer tycker jag jag har följt relativt väl i projketet gällande det publika interfaceet och när skrev koden kändes det lite omständigt och onödigt att bryta ut logik på det sättet för simpla metoder. Nu ser jag dock värdet i det och tycker min kod är lätt att följa jämfört med andra projekt jag gjort / jämfört med om jag hade gjort på mina vanliga vis. Exempelvis :https://github.com/lb224nj/1dv610_L2/blob/main/src/calculations/medianValueCalculations.js#L41 blir i mina ögon lätt att förstå på grund av att logik är utbruten (och namngivningen). En till viktig lärdom jag tar med mig är att kod kan mer lättförstålig, lättare att testa och mina ögon bättre, med relativt små medel. Exempelvis genom att använda **Argument Objects** när argumenten blir många vilket såhär i efterhand känns ganska självklart och till viss grad provocerande att jag inte reflekterat över tidigare. Sammantaget skulle jag vilja beskriva det som att mitt synsätt på processen av att skriva kod har skiftat, från att lösa specifika problem med vilka medel som helst, till att lösa specifika problem på ett sätt som syftar till att skapa lätthanterlig och lättunderhållen kod och genom en process som genomsyrats av medvetna val. En metafor skulle kunna vara när man lär sig att (8 + 8 + 8) lättare skrivs som (8 x 3) och att det är ett tydligare sätt att beskriva uträkningen för alla som är verksamma inom området. Utbruten logik och kortare kod är lättare att läsa, och mer förståeligt för de som är insatta inom området.
 
